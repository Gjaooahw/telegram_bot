# Импортируем модуль sqlite3 для работы с базой данных SQLite
import sqlite3
# Импортируем 'types' из telebot для создания кнопок и клавиатур (InlineKeyboardMarkup, InlineKeyboardButton)
from telebot import types
# Импортируем основную библиотеку telebot для создания и управления ботом
import telebot

# Создаем экземпляр (объект) бота, указывая его API-токен
# ВАЖНО: Никогда не "зашивайте" токен прямо в код в реальных проектах. Используйте переменные окружения.
bot = telebot.TeleBot("TOKEN_СКРЫТ_ ДЛЯ_БЕЗОПАСНОСТИ")

# Глобальная переменная для временного хранения имени пользователя между шагами (между user_name и user_password)
# (Это простой, но не самый надежный способ. Для сложных ботов лучше использовать FSM (Finite State Machine) или базу данных состояний)
name = None


# ---------- 1. Обработка команды /start ----------

# @bot.message_handler - это декоратор. Он говорит telebot: "Если придет сообщение,
# которое является командой 'start', вызови функцию 'launch'".
@bot.message_handler(commands=['start'])
def launch(message):
    # 'message' - это объект, содержащий всю информацию о пришедшем сообщении (кто отправил, какой текст и т.д.)

    # Подключаемся к файлу базы данных 'database.sqlite'.
    # Если этого файла нет, SQLite его автоматически создаст в той же папке.
    conn = sqlite3.connect('database.sqlite')
    # Создаем объект 'cursor' (курсор). Он нужен для выполнения SQL-запросов к базе данных.
    cursor = conn.cursor()

    # Выполняем SQL-запрос:
    # "СОЗДАТЬ ТАБЛИЦУ, ЕСЛИ ОНА ЕЩЁ НЕ СУЩЕСТВУЕТ, с именем 'users'"
    # "В таблице будут столбцы:"
    # "id INTEGER PRIMARY KEY AUTOINCREMENT - целочисленный ID, первичный ключ, который будет сам увеличиваться (1, 2, 3...)"
    # "name TEXT - текстовый столбец для имени"
    # "password TEXT - текстовый столбец для пароля"
    cursor.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, password TEXT)')

    # Сохраняем (подтверждаем) изменения, сделанные в базе данных (в данном случае - создание таблицы).
    conn.commit()
    # Закрываем курсор (хорошая практика)
    cursor.close()
    # Закрываем соединение с базой данных (обязательно!)
    conn.close()

    # Отправляем приветственное сообщение пользователю (в тот же чат, откуда пришел /start)
    bot.send_message(message.chat.id, 'Привет, мы тебя зарегистрируем сейчас,введите свое имя')

    # Говорим боту: "Следующее сообщение, которое пришлет ЭТОТ ЖЕ пользователь (из message.chat.id),
    # нужно передать для обработки в функцию user_name".
    # Это механизм "состояний" или "последовательных шагов".
    bot.register_next_step_handler(message, user_name)


# ---------- 2. Получаем имя пользователя ----------

# Эта функция будет вызвана автоматически после 'launch', когда пользователь введет свое имя.
def user_name(message):
    # Указываем, что мы хотим использовать (и изменять) глобальную переменную 'name', объявленную выше
    global name
    # Получаем текст из сообщения пользователя (message.text)
    # .strip() убирает лишние пробелы в начале и конце (например, если пользователь случайно их ввел)
    name = message.text.strip()
    # Отправляем следующий вопрос
    bot.send_message(message.chat.id, 'Введите пароль:')
    # Снова регистрируем следующий шаг: теперь ждем пароль и передаем его в функцию 'user_password'
    bot.register_next_step_handler(message, user_password)


# ---------- 3. Получаем пароль и сохраняем данные ----------

# Эта функция вызывается после 'user_name', когда пользователь вводит пароль.
def user_password(message):
    # Получаем пароль, убираем пробелы
    password = message.text.strip()

    # Снова подключаемся к базе данных
    conn = sqlite3.connect('database.sqlite')
    # Создаем курсор
    cursor = conn.cursor()

    # Добавляем нового пользователя в таблицу
    # Выполняем SQL-запрос: "ВСТАВИТЬ В таблицу 'users' (в столбцы name, password) ЗНАЧЕНИЯ (?, ?)"
    # Вместо '?' SQLite безопасно подставит значения из кортежа (name, password)
    # 'name' берется из глобальной переменной, 'password' - из этой функции.
    # Использование '?' - это параметризированный запрос, он защищает от SQL-инъекций.
    cursor.execute("INSERT INTO users(name, password) VALUES (?, ?)", (name, password))

    # Сохраняем изменения (т.е. добавление нового пользователя)
    conn.commit()

    # Закрываем соединение
    cursor.close()
    conn.close()

    # --- Создаём инлайн-клавиатуру ---
    # Инлайн-кнопки - это кнопки, которые появляются прямо под сообщением бота.
    markup = types.InlineKeyboardMarkup()  # Создаем объект пустой клавиатуры
    # Создаем кнопку. 'Список пользователей' - текст на кнопке.
    # 'callback_data='users'' - это "скрытые" данные, которые бот получит, когда пользователь нажмет эту кнопку.
    btn = types.InlineKeyboardButton('Список пользователей', callback_data='users')
    markup.add(btn)  # Добавляем кнопку в клавиатуру

    # Отправляем сообщение "Пользователь зарегистрирован"
    # и прикрепляем к нему нашу клавиатуру (reply_markup=markup)
    bot.send_message(message.chat.id, 'Пользователь зарегистрирован', reply_markup=markup)

# --- Обработчик нажатий на инлайн-кнопки ---

# Этот декоратор "ловит" нажатия на *любые* инлайн-кнопки (callback_query).
# 'func=lambda call: True' означает, что он сработает для любого 'call' (нажатия).
@bot.callback_query_handler(func=lambda call: True)
def callback(call):
    # 'call' - это объект, содержащий информацию о нажатии (кто нажал, какое 'callback_data' пришло и т.д.)
    # В нашем случае мы ожидаем, что call.data будет равно 'users'.

    # (Здесь стоило бы добавить проверку: if call.data == 'users':)

    # Подключаемся к базе
    conn = sqlite3.connect('database.sqlite')
    cursor = conn.cursor()

    # Выполняем SQL-запрос: "ВЫБРАТЬ * (все столбцы) ИЗ таблицы 'users'"
    cursor.execute('SELECT * FROM users')
    # .fetchall() забирает *все* строки, найденные запросом,
    # и возвращает их в виде списка кортежей.
    # Например: [(1, 'Иван', '123'), (2, 'Анна', 'qwe')]
    users = cursor.fetchall()

    # Создаем пустую строку, в которую будем "собирать" список пользователей
    info = ''
    # Проходим циклом по каждой строке ('us') в списке 'users'
    for us in users:
        # Добавляем (+=) к строке 'info' отформатированную f-строку
        # us[0] - это id (индекс 0)
        # us[1] - это name (индекс 1)
        # us[2] - это password (индекс 2)
        # '\n' - добавляем перенос строки, чтобы каждый пользователь был на новой строке
        info += f'Name: {us[1]}, Password: {us[2]}\n'

    # Сохраняем изменения (conn.commit())
    # ВАЖНО: .commit() здесь не нужен, так как мы ничего не меняли в базе (делали только SELECT).
    # Но ошибки он не вызовет.
    conn.commit()

    # Закрываем соединение
    cursor.close()
    conn.close()

    # Отправляем собранный список 'info' пользователю
    # 'call.message.chat.id' - это ID чата, в котором находится сообщение с кнопкой, на которую нажали
    bot.send_message(call.message.chat.id, info)


# ---------- 4. Запуск бесконечного цикла обработки сообщений ----------

# bot.polling(none_stop=True) - старый вариант
# bot.infinity_polling() - новый (предпочтительный) вариант
# Эта строка запускает бота. Он будет постоянно "опрашивать" серверы Telegram,
# нет ли для него новых сообщений (это называется long polling).
# Скрипт будет работать бесконечно, пока вы его не остановите принудительно (например, Ctrl+C в терминале).
bot.infinity_polling()
